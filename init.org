* Header bits

Before anything else, we need to bootstrap up a working implementation
of use-package so that we can install all the other packages that we
desire

#+BEGIN_SRC emacs-lisp :tangle yes
(setq package-archives
 (quote
  (("gnu" . "http://elpa.gnu.org/packages/")
   ("org" . "http://orgmode.org/elpa/")
   ; ("marmalade" . "http://marmalade-repo.org/packages/")
   ("melpa" . "http://melpa.milkbox.net/packages/"))))
(package-initialize)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))

#+END_SRC

Load the string package.  We need this for a lot of the other code.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package s
  :ensure t)

#+END_SRC

** Common libraries

*** evil

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil
  :ensure t
  :init (setq evil-want-integration nil)
  :config
  (setq evil-escape-unordered-key-sequence t)
  (setq evil-insert-state-modes
	'(comint-mode erc-mode eshell-mode geiser-repl-mode gud-mode inferior-apl-mode inferior-caml-mode inferior-emacs-lisp-mode inferior-j-mode inferior-python-mode inferior-scheme-mode inferior-sml-mode internal-ange-ftp-mode prolog-inferior-mode reb-mode shell-mode slime-repl-mode term-mode wdired-mode))
  (evil-mode)
  ;; (evil-add-hjkl-bindings
  ;;   eww-mode-map 'emacs
  ;;   (kbd "f") 'ace-link-eww
  ;;   (kbd "o") 'eww
  ;;   (kbd "r") 'eww-reload
  ;;   (kbd "gr") 'eww-readable)
  (add-hook 'git-commit-mode-hook #'evil-insert-state))
 #+END_SRC

*** general

The general package is a set of convenience scripts for defining key
bindings

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package general
  :ensure t
  :config
  (setq general-default-prefix "SPC")
  (setq general-default-non-normal-prefix "M-SPC")
  (setq general-default-states '(normal insert emacs))

  (general-simulate-keys
   "C-c C-c" 't
   :docstring
   "Run whatever the native mode's C-c C-c command would be"
   :name
   general-simulate-C-c_C-c-in-emacs-state)

  (general-define-key
   "cc" #'general-simulate-C-c_C-c-in-emacs-state)

  (general-define-key
   :keymaps 'with-editor-mode-map
   "ck" 'with-editor-cancel)

  (general-define-key
   "/" 'swiper
   "?" 'swiper-all)

  (general-define-key
   :infix "x"
   "s" 'save-buffer
   "B" 'ibuffer
   "k" 'kill-this-buffer
   "e" 'eval-last-sexp))

(defun avy-jump-link ()
   (interactive)
   (avy--generic-jump "https://" nil 'pre))

(general-define-key
 :prefix 'nil
 :infix 'nil
 "M-o" 'avy-jump-link)

#+END_SRC

#+RESULTS:


*** evil collection

A set of evil bindings for multiple modes.  This should make life less
frustrating

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))

#+END_SRC

*** which-key



  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package which-key
  :diminish which-key-mode
  :ensure t
  :config
  (which-key-mode)
  (setq which-key-show-operator-state-maps t))
  #+END_SRC


*** evil-magit

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-magit
  :ensure t)
  #+END_SRC

*** evil org mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org
  :diminish evil-org-mode
  :ensure t
  :after org
  :config
  (require 'evil-org)
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook
            (lambda ()
              (evil-org-set-key-theme))))

#+END_SRC

*** evil-indent-plus
Evil indent plus does a great job at handling Python and Haskell
source code

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-indent-plus
  :ensure t
  :config
  (evil-indent-plus-default-bindings))

#+END_SRC


*** evil quickscope

evil quickscope highlight unique characters in the words around the
cursor to identify the best options for using the f/t/F/T keys for
navigation.  If there is no best single character, it uses a blue
highlight to indicate that a 2f/2F will still find the correct word.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-quickscope
  :ensure t
  :config
  (global-evil-quickscope-mode 1))

#+END_SRC

*** Evil Goggles

Evil google should make learning evil slightly easier, as it shows the
exact regions chosen.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-goggles
  :ensure t
  :config
  (evil-goggles-mode))

#+END_SRC

*** evil text object python

This package allows for using evil operations on the structure of
python statements, instead of just looking at things on a line by line
basis.  Due to Python's whitespace sensitive setup, this might be
necessary.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-text-object-python
  :ensure t
  :config
  (add-hook 'python-mode-hook 'evil-text-object-python-add-bindings))

#+END_SRC


*** evil matichit

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-matchit
  :ensure t
  :config
  (global-evil-matchit-mode 1))

#+END_SRC


*** evil-escape

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-escape
  :ensure t
  :diminish evil-escape-mode
  :config
  (evil-escape-mode)
  (setq-default evil-escape-key-sequence "jk"))
  #+END_SRC


*** evil easymotion

easymotion helps with the fact that I don't instantly know how many
lines or characters I'm looking at 90% of the time when using evil.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-easymotion
  :ensure t
  :config
  (evilem-default-keybindings "RET"))


#+END_SRC

*** evil commentary

Evil commentary should hopefully give me the commenting options that
evil-nerd-commenter sould never get working right

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-commentary
  :ensure t
  :config
  (evil-commentary-mode))
#+END_SRC

*** evil numbers

    This should allow for easier number manipulation in evil mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-numbers
  :ensure t
  :config
  (general-define-key
   :prefix 'nil
   :states '(normal)
   :infix "g"
   "+" 'evil-numbers/inc-at-pt
   "-" 'evil-numbers/dec-at-pt))

#+END_SRC

** Machine recognition

Since different computers have different file structures and
capabilities, Emacs needs to customise itself for the specific
computer that it is running on.  To this end, the functions below
identify computers and operating systems.  This should simplify much
of the code.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun insert-system-name ()
  "Get current system's name."
  (interactive)
  (insert (format "%s" (system-name))))

(defun insert-system-type ()
  "Get the current system OS."
  (interactive)
  (insert (format "%s" system-type)))

(defun system-is-darwin ()
  "Are we on a Mac?"
  (string-equal system-type "darwin"))

(defun system-is-windows ()
  "Are we on (*shudder*) Windows?"
  (string-equal system-type "windows-nt"))

(defun system-is-linux ()
  "Are we on Linux?"
  (string-equal system-type "gnu/linux"))

(defun system-is-arch ()
  "Are we on the Arch Virtualbox?"
  (or
   (s-starts-with? "NDLT969a" (system-name))
   (s-starts-with? "NDW1748" (system-name))))

(defun system-is-sheffield ()
  "Are we on the old Sheffield workstation?"
  (s-ends-with? "shef.ac.uk" (system-name)))

(defun system-is-macbook ()
  "Are we on my Sheffield Macbook?"
  (or
   (s-starts-with? "adams-mbp" (system-name))
   (s-starts-with? "Adams-MBP" (system-name))
   (s-starts-with? "Adams-MacBook" (system-name))))
#+END_SRC

** Handle system paths

#+BEGIN_SRC emacs-lisp :tangle yes

(let
    ((mypaths
      (cond
       ((system-is-sheffield)
        (list
         "$NPM_PACKAGES/bin"
         "/home/adam/.local/bin"
         "/home/adam/bin"
         "/usr/local/texlive/2015/bin/x86_64-linux"
         "/usr/local/MATLAB/MATLAB_Compiler_Runtime/v82/runtime/glnxa64"
         "/usr/local/MATLAB/MATLAB_Compiler_Runtime/v82/bin/glnxa64"
         "/usr/local/MATLAB/MATLAB_Compiler_Runtime/v82/sys/os/glnxa64"
         "/usr/local/MATLAB/MATLAB_Compiler_Runtime/v82/sys/java/jre/glnxa64/jre/lib/amd64/native_threads"
         "/usr/local/MATLAB/MATLAB_Compiler_Runtime/v82/sys/java/jre/glnxa64/jre/lib/amd64/server"
         "/usr/local/MATLAB/MATLAB_Compiler_Runtime/v82/sys/java/jre/glnxa64/jre/lib/amd64"
         "/home/adam/.cabal/bin"
         "/home/adam/.npm-packages/bin/"
         "/usr/local/bin"
         "/home/adam/Science/LINUX64"
         "/opt/maple18/bin"
         "/usr/local/cuda-7.5/bin"
         "/usr/bin"
         "/bin"
         (getenv "PATH")))
         ((system-is-macbook)
          (list
           "/Users/adam/Library/Python/2.7/bin/"
           "/Users/adam/.local/bin/"
           "/opt/local/bin"
           "/opt/local/sbin"
           "/usr/local/bin"
           "/usr/bin"
           "/bin"
           "/usr/sbin"
           "/sbin"
           "/opt/X11/bin"
           "/Library/Frameworks/Mono.framework/Versions/Current/Commands"))
	 ((system-is-arch)
	  (append
	   (split-string (getenv "PATH") ":")
	   (list "~/bin")))
       ('t (split-string (getenv "PATH") ":")))))
  (if
      (not (system-is-windows))
      (progn
	(setenv "PATH" (mapconcat 'identity mypaths ":"))
	(setq exec-path (append mypaths (list "." exec-directory))))))

(setq w32-apps-modifier 'super)


#+END_SRC

** Prettify

Next, let's get rid of the window chrome.  It's just so ugly.

#+BEGIN_SRC emacs-lisp :tangle yes
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)

#+END_SRC

Similarly, get rid of the awful startup screen.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq inhibit-startup-screen t)

#+END_SRC

Let's set the default font and size

#+BEGIN_SRC emacs-lisp :tangle yes
(set-fontset-font "fontset-default" nil
                  (font-spec :size 12 :name "DejaVu Sans"))

(set-fontset-font "fontset-default" nil
                  (font-spec :size 20 :name "DejaVu Sans"))

#+END_SRC

Make everything pretty!

#+BEGIN_SRC emacs-lisp :tangle yes
(global-prettify-symbols-mode t)

#+END_SRC

** Unsorted

Use diminish to stop minor modes from taking over the entire taskbar.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  :ensure t
  :config
  (diminish 'auto-revert-mode "")
  (diminish 'auto-fill-mode "")
  (diminish 'visual-line-mode "")
  (diminish 'flyspell-mode "")
  (diminish 'undo-tree-mode "")
  (diminish 'auto-fill-function ""))


#+END_SRC

Always use spaces instead of tabs to avoid complaints from bored
people on the internet.

#+BEGIN_SRC emacs-lisp :tangle yes

 '(indent-tabs-mode nil)

#+END_SRC

Use the TeX input method to get those glorious unicode characters.

#+BEGIN_SRC emacs-lisp :tangle yes

(setq default-input-method "TeX")
(toggle-input-method)

#+END_SRC

Emacs gives us line numbers by default, but not column numbers.  I
think that that's a legacy decision left over from the terminal days?
Either way, I disagree with it, so we'll put the column numbers in.

#+BEGIN_SRC emacs-lisp :tangle yes

(setq column-number-mode t)

#+END_SRC

Tell emacs to treat all themes as safe.  This is, honestly, a gapping
security hole, but I only install themes from trusted sources and I'm
not auditing them as it currently is.  Plus, this gets the terrible
custom-safe-themes variable out of customize

#+BEGIN_SRC emacs-lisp :tangle yes

(setq custom-safe-themes t)

#+END_SRC

Give a default e-mail address.

#+BEGIN_SRC emacs-lisp :tangle yes

(setq user-mail-address "adam.washington@stfc.ac.uk")

#+END_SRC

I don't like emacs backup files.  They're coarse and rough and
irritating, and the get everywhere.  I'm going to confine them to a
single directory.

#+BEGIN_SRC emacs-lisp :tangle yes

(setq backup-by-copying t)
(setq backup-directory-alist (quote (("." . "~/.saves"))))
(setq delete-old-versions t)
(setq kept-new-versions 6)
(setq vc-make-backup-files t)
(setq version-control t)

#+END_SRC


* Themes

   Load a theme based on my base16 configurations

#+BEGIN_SRC emacs-lisp :tangle yes

(load-file "~/Code/dotfiles/base16/emacs")

#+END_SRC
* Apps
** Dired

Dired is a wonderful way of handling directories.

Setting dired-dwim-target causes dired to default to sending files to
the directory in the other dired window, making copying files between
two directories far more reasonable.
#+BEGIN_SRC emacs-lisp :tangle yes

(setq dired-dwim-target t)

#+END_SRC

Adding the =h= switch onto dired listing gives file sizes in a human
readable format, instead of just a raw byte counts

#+BEGIN_SRC emacs-lisp :tangle yes
(setq dired-listing-switches "-alh")

#+END_SRC

Get dired to intergate with imenu, since that just makes sense.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-imenu
  :ensure t)

#+END_SRC

Direct Quick Sort offers more sorting optins than just name and time

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package dired-quick-sort
  :ensure t
  :config
  (dired-quick-sort-setup))
#+END_SRC

Dired-collapse gets rid of annoying chains of single file directories

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package dired-collapse
  :ensure t)

#+END_SRC


Dired imenu makes dired navigation so much more consistent with the
rest of evil.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-imenu
:ensure t)

#+END_SRC

** Images

Load images as images, instead of as bye arrays

#+BEGIN_SRC emacs-lisp :tangle yes

(setq auto-image-file-mode t)

#+END_SRC

Always revert images files without asking.

#+BEGIN_SRC emacs-lisp :tangle yes

(setq revert-without-query '(".png"))

#+END_SRC
** magit

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :ensure t
  :init
  (if
      (system-is-macbook)
      (setq magit-git-executable "/usr/bin/git"))
  :config
  (setq diff-switches "-u")
  (setq magit-commit-arguments (quote ("--gpg-sign=0D2B93AB0C87BAF1")))
  (setq magit-bury-buffer-function 'magit-mode-quit-window))
 #+END_SRC
** magithub

   This package let's me interface with github through magit.
   Anything to stay out of the browser.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package magithub
  :ensure t
  :after magit
  :config (magithub-feature-autoinject t))
#+END_SRC

** ledger-mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ledger-mode
  :ensure t)
 #+END_SRC


** pass

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package pass
  :ensure t)
 #+END_SRC


* Code


** Universal

Which-function mode helps me when I'm stuck in some giant routine and
lose track of where I am in the program.  There's the function, right
there on the modeline.

#+BEGIN_SRC emacs-lisp :tangle yes
(which-function-mode 't)
(set-face-foreground 'which-func (face-foreground font-lock-variable-name-face))

#+END_SRC
** C♯

Set the C♯ compiler for linux

#+BEGIN_SRC emacs-lisp :tangle yes

(setq csharp-make-tool "mcs")

#+END_SRC
** emacs-lisp

Let's try and make elisp symbols pretty!

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (push '("<=" . ?≤) prettify-symbols-alist)
            (push '("**2" . ?²) prettify-symbols-alist)))


#+END_SRC
** haskell-mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package haskell-mode
  :ensure t
  :config
  (setq haskell-tags-on-save t)

  ;; (autoload 'ghc-init "ghc" nil t)
  ;; (autoload 'ghc-debug "ghc" nil t)
  ;; (add-hook 'haskell-mode-hook (lambda () (ghc-init)))
  (add-hook 'haskell-mode-hook 'flycheck-mode)
  ;; (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
  (add-hook
   'haskell-mode-hook
   (lambda ()
     (push '("\\" . ?λ) prettify-symbols-alist)
     (push '(">>=" . ?↣) prettify-symbols-alist)
     (push '("->" . ?→) prettify-symbols-alist)
     (push '("<-" . ?←) prettify-symbols-alist)
     (push '("=>" . ?⇒) prettify-symbols-alist)
     (push '("not" . ?¬) prettify-symbols-alist)
     (push '("==" . ?≟) prettify-symbols-alist)
     (push '("/=" . ?≠) prettify-symbols-alist)
     (push '("<=" . ?≤) prettify-symbols-alist)
     (push '(">=" . ?≥) prettify-symbols-alist)
     (push '("=" . ?≡) prettify-symbols-alist)
     (push '("pi" . ?π) prettify-symbols-alist)
     (push '(">>" . ?≫) prettify-symbols-alist)
     (push '("<<" . ?≪) prettify-symbols-alist)
     (push '("++" . ?⧺) prettify-symbols-alist)
     (push '("*" . ?⋅) prettify-symbols-alist)
     (push '(" . " . ?∘) prettify-symbols-alist)
     (push '("<*>" . ?⊛) prettify-symbols-alist)
     (push '("<+>" . ?⊕) prettify-symbols-alist)
     (push '("::" . ?⁝) prettify-symbols-alist))))
 #+END_SRC


 I've added command line completion for cabal and stack, since I'm too
 lazy to type out my executable names on my own.

#+BEGIN_SRC emacs-lisp :tangle yes
(defconst pcmpl-cabal-commands
  '("update" "install" "help" "info" "list" "fetch" "user" "get" "init" "configure" "build"
  "clean" "run" "repl" "test" "bench" "check" "sdist" "upload" "report" "freeze" "gen"
  "haddock" "hscolour" "copy" "register" "sandbox" "exec" "repl"))

(defun pcmpl-cabal-get-execs ()
  (with-temp-buffer
    (message "Loading")
    (insert (shell-command-to-string "cat *.cabal"))
    (goto-char (point-min))
    (let ((ref-list))
      (while (re-search-forward "^executable +\\(.+\\) *$" nil t)
        (message "Insert")
        (add-to-list 'ref-list (match-string 1)))
      ref-list)))

(defun pcomplete/cabal ()
  "Completion for `cabal'"
  (pcomplete-here* pcmpl-cabal-commands)

  (cond
   ((pcomplete-match (regexp-opt '("run")) 1)
    (pcomplete-here* (pcmpl-cabal-get-execs)))))

(defconst pcmpl-stack-commands
  '( "build" "install" "uninstall" "test" "bench" "haddock" "new" "templates" "init" "solver"
  "setup" "path" "unpack" "update" "upgrade" "upload" "sdist" "dot" "exec" "ghc" "ghci"
  "repl" "runghc" "runhaskell" "eval" "clean" "list" "query" "ide" "docker" "config" "image" "hpc")
  "List of Stack Commands")

(defun pcomplete/stack ()
  "Completion for `stack'"
  (pcomplete-here* pcmpl-stack-commands)

  (cond
   ((pcomplete-match (regexp-opt '("exec")) 1)
    (pcomplete-here* (pcmpl-cabal-get-execs)))))


#+END_SRC
*** intero

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package intero
  :ensure t
  ;:config
  ;(add-hook 'haskell-mode-hook 'intero-mode))
  )
  #+END_SRC

** flymake-jshint

 #+BEGIN_SRC emacs-lisp :tangle no
(use-package flymake-jshint
  :ensure t
  :config
  (flymake-jshint-load))
 #+END_SRC



** Python

Let's make our python prettier, too!

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'python-mode-hook
          (lambda ()
            (push '("<=" . ?≤) prettify-symbols-alist)
            (push '(">=" . ?≥) prettify-symbols-alist)
            (push '("!=" . ?≠) prettify-symbols-alist)
            (push '("np.pi" . ?π) prettify-symbols-alist)
            (push '("np.sum" . ?Σ) prettify-symbols-alist)
            (push '("np.sqrt" . ?√) prettify-symbols-alist)
            (push '("sqrt" . ?√) prettify-symbols-alist)
            (push '("sum" . ?Σ) prettify-symbols-alist)
            (push '("alpha" . ?α) prettify-symbols-alist)
            (push '("sigma" . ?σ) prettify-symbols-alist)
            (push '("lambda" . ?λ) prettify-symbols-alist)
            (push '("**2" . ?²) prettify-symbols-alist)))
#+END_SRC

Add support to python mode for finding errors

Add mypy for doing type checking

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-mypy
  :ensure t)

#+END_SRC

** rainbow-delimiters

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
             :ensure t
             :config
             (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
 #+END_SRC
** Systemd

I need to be able to edit systemd service files.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package systemd
  :ensure t)

#+END_SRC




** nix

Add nix-mode for editting nix files

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package nix-mode
  :ensure t)

#+END_SRC
* Communication Tools

  We need spell checking in generic Mail mode.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'mail-mode-hook 'flyspell-mode)

#+END_SRC

Also, there are some generic message mode settings that I need to
review again so that I can remember exactly how they work.  FIXME

#+BEGIN_SRC emacs-lisp :tangle yes


(setq message-send-mail-function 'message-send-mail-with-sendmail)
(setq message-sendmail-envelope-from 'header)
(setq message-sendmail-extra-arguments '("--read-envelope-from"))
(setq message-sendmail-f-is-evil t)

#+END_SRC

** eww 

 We will use =eww= as our default browser, with the option to escape
 to firefox if things get bad.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq browse-url-browser-function 'eww-browse-url)
#+END_SRC

I customise the eww bindings to make them more [[evil][VimFx]]

** jabber

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package jabber
  :ensure t
  :defer t
  :config
  (progn
   (let
    ((passwd (funcall (plist-get (car (auth-source-search :max 1 :host "talk.google.com")) :secret))))
    (setq
     jabber-account-list
     `(("rprospero@gmail.com"
        (:port . 5223)
        (:password . ,passwd)
        (:network-server . "talk.google.com")
        (:connection-type . ssl)))))
   (defun x-urgency-hint (frame arg &optional source)
     (let* ((wm-hints (append (x-window-property
                               "WM_HINTS" frame "WM_HINTS" source nil t) nil))
            (flags (car wm-hints)))
       (setcar wm-hints
               (if arg
                   (logior flags #x100)
                 (logand flags (lognot #x100))))
       (x-change-window-property "WM_HINTS" wm-hints frame "WM_HINTS" 32 t)))
   (defun jabber-notify-taffy ()
     (if (equal "0" jabber-activity-count-string) t
       (progn
         ;; (notifications-notify
         ;;  :title jabber-activity-make-string
         ;;  :body jabber-activity-count-string)
         (x-urgency-hint (selected-frame) t))))
   (setq jabber-chat-buffer-show-avatar nil)
   (setq jabber-vcard-avatars-retrieve nil)
   (add-hook 'jabber-chat-mode-hook 'flyspell-mode)
   (add-hook 'jabber-activity-update-hook 'jabber-notify-taffy)))


 #+END_SRC


** twittering-mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package twittering-mode
             :bind (("C-c t" . twit))
	     :ensure t
             :config
	     (add-hook 'twittering-edit-mode-hook 'company-mode)
             (setq twittering-use-master-password t)
             (setq twittering-timer-interval 30))
 #+END_SRC


** sx

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package sx
  :ensure t)
 #+END_SRC



** gnus

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package gnus
  :config
  (progn
    (setq gnus-select-method '(nntp "news.gwene.org"))
    (setq
     gnus-secondary-select-methods
     (quote
      ((nnmaildir "Professional"
                  (directory "~/Maildir/Professional"))
       (nnmaildir "Work"
                  (directory "~/Maildir/Work"))
       (nnmaildir "Personal"
                  (directory "~/Maildir/Personal")))))

    (setq
     send-mail-function
     (quote smtpmail-send-it))
    (setq
     sendmail-program
     "msmtp")
    (setq
     message-send-mail-function
     (quote message-send-mail-with-sendmail))
    (setq
     message-sendmail-envelope-from
     (quote header))
    (setq
     message-sendmail-extra-arguments
     (quote ("--read-envelope-from")))
    (setq
     message-sendmail-f-is-evil
     t)

    (defun gnus-keys ()
      (local-set-key ["S-delete"] 'gnus-summary-delete-article))

    (add-hook 'gnus-summary-mode-hook 'gnus-keys)))
 #+END_SRC


** notmuch

notmuch is a wonderful little utility for managing my mail

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package notmuch
  :ensure t
  :config
  (setq notmuch-archive-tags (quote ("-inbox" "-unread")))
  (set-face-attribute 'notmuch-search-unread-face nil
	:foreground "#859900")
  (setq notmuch-fcc-dirs
   (quote
    (("rprospero@gmail.com" . "Personal/[Gmail].Sent Mail")
     ("adam.washington@stfc.ac.uk" . "Work/Sent -inbox -unread +sent"))))
  (setq notmuch-hello-thousands-separator ",")
  (setq notmuch-saved-searches
        (quote
         ((:name "inbox" :query "tag:inbox" :key "i")
          (:name "unread" :query "tag:unread" :key "u")
          (:name "flagged" :query "tag:flagged" :key "f")
          (:name "sent" :query "tag:sent" :key "t")
          (:name "drafts" :query "tag:draft" :key "d")
          (:name "all mail" :query "*" :key "a")
          (:name "Today's mail" :query "date:0d..")
          (:name "promotional" :query "to:promotional tag:inbox")
          (:name "SasView" :query "Sas from:notifications@github.com")))))

#+END_SRC
** elfeed

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package elfeed
  :bind (("C-c c" . org-capture))
  :ensure t
  :config
  (setq
   elfeed-feeds
   '(("http://www.xkcd.org/atom.xml" comic)
     ("http://phdcomics.com/gradfeed.php" comic)
     ("http://www.merriam-webster.com/wotd/feed/rss2" education)
     ("http://sachachua.com/blog/feed/" sw emacs)
     ("https://planet.haskell.org/rss20.xml" sw haskell)
     ("https://wordsmith.org/awad/rss1.xml" education)
     ("http://emacsninja.com/feed.atom" sw emacs)
     ("http://emacshorrors.com/feed.atom" sw emacs)
     ("https://blogs.msdn.microsoft.com/oldnewthing/feed" sw tech)
     ("http://endlessparentheses.com/atom.xml" sw emacs)
     ("http://pragmaticemacs.com/feed/" sw emacs)
     ("https://www.reddit.com/r/emacs/.rss" sw emacs)
     ("https://www.reddit.com/r/haskell/.rss" sw haskell)
     ("https://www.reddit.com/r/julia/.rss" sw julia)
     ("https://hnrss.org/newest?points=300" sw tech)
     ("https://yager.io/feed/" sw haskell)
     "http://us10.campaign-archive1.com/feed?u=49a6a2e17b12be2c5c4dcb232&id=ffbbbbd930")))

 #+END_SRC

 #+RESULTS:
 : t

** Slack

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package slack
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
  (setq slack-prefer-current-team t)
  :config

  (slack-register-team
   :name "SasView"
   :client-id "165525662918.164903213860"
   :client-secret (funcall (plist-get (car (auth-source-search :max 1 :host "sasview.slack.com")) :secret))
   :token (funcall (plist-get (car (auth-source-search :max 1 :host "token.sasview.slack.com")) :secret))
   :subscribed-channels '(general random build github trac jenkins))

  (evil-define-key 'normal slack-info-mode-map
    ",u" 'slack-room-update-messages)
  (evil-define-key 'normal slack-mode-map
    ",c" 'slack-buffer-kill
    ",ra" 'slack-message-add-reaction
    ",rr" 'slack-message-remove-reaction
    ",rs" 'slack-message-show-reaction-users
    ",pl" 'slack-room-pins-list
    ",pa" 'slack-message-pins-add
    ",pr" 'slack-message-pins-remove
    ",mm" 'slack-message-write-another-buffer
    ",me" 'slack-message-edit
    ",md" 'slack-message-delete
    ",u" 'slack-room-update-messages
    ",2" 'slack-message-embed-mention
    ",3" 'slack-message-embed-channel
    "\C-n" 'slack-buffer-goto-next-message
    "\C-p" 'slack-buffer-goto-prev-message)
   (evil-define-key 'normal slack-edit-message-mode-map
    ",k" 'slack-message-cancel-edit
    ",s" 'slack-message-send-from-buffer
    ",2" 'slack-message-embed-mention
    ",3" 'slack-message-embed-channel))

#+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp :tangle yes
(setq my-tramp-ssh-completions
      '((tramp-parse-sconfig "~/.ssh/config")
	(tramp-parse-sknownhosts "~/.ssh/known_hosts")))

(mapc
 (lambda (method)
   (tramp-set-completion-function method my-tramp-ssh-completions))
 '("fcp" "rsync" "scp" "scpc" "scpx" "sftp" "ssh" "sshx"))

#+END_SRC

** EUDC

EUDC is the LDAP client for emacs.  It should allow me to query the
directory of STFC.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook
 'eudc-mode-hook
 (lambda ()
   (progn
     (setq eudc-server-hotlist
	   (quote (("127.0.0.1:1389" . ldap))))
     (setq ldap-host-parameters-alist
	   `(("127.0.0.1:1389"
	      base "ou=people"
	      binddn "CLRC\\auv61894"
	      passwd ,(funcall (plist-get (car (auth-source-search :max 1 :host "127.0.0.1" :port 1389)) :secret))
	      auth simple))))))

#+END_SRC


** excorporate

Excorporate pulls calendar data from an exchange server.  I've then
written *way* too much code to allow this to interface with the
org-mode agenda, allowing me to insert my outlook agenda directly into org.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package excorporate
  :ensure t
  :config
  (setq excorporate-configuration "adam.washington@stfc.ac.uk"))

#+END_SRC

*** excorporate org

This is my little code to put my Exchange calendar into my
org-agenda.  It's probably horribly broken.  Additionally, it depends
on [[https://github.com/skeeto/elisp-latch][latch.el]], which isn't available as a package and had to be
installed manually.

At some point, I need to turn this into a proper package.

#+BEGIN_SRC elisp :tangle yes
(add-to-list 'load-path "/home/adam/.emacs.d/scripts")

(require 'latch)

(defun excorporate-first-meeting (&optional mark)
  (if exco--connections
      (let
	  ((meeting (car-safe (adam-get-meetings date))))
	(if meeting
	    (format
	     "%s %s"

	     (if (plist-get meeting 'all-day)
		""
	       (adam-relative-date-format
		(plist-get meeting 'start)
		(plist-get meeting 'stop)
		date))
	     (plist-get meeting 'subject))))))

(defun excorporate-second-meeting (&optional mark)
  (if exco--connections
      (let
	  ((meeting (car-safe (cdr-safe (adam-get-meetings date)))))
	(if meeting
	    (format
	     "%s %s"

	     (if (plist-get meeting 'all-day)
		""
	       (adam-relative-date-format
		(plist-get meeting 'start)
		(plist-get meeting 'stop)
		date))
	     (plist-get meeting 'subject))))))

(defun adam-relative-date-format (begin end local)
     (pcase-let
	 ((`(,month ,day ,year) local)
       	  (`(,es ,em ,eh ,eD ,eM ,eY) begin)
       	  (`(,bs ,bm ,bh ,bD ,bM ,bY) end))
       (cond
	((and (= day eD) (= month eM) (= year eY)
	      (= day bD) (= month bM) (= year bY))
	 (format "%2d:%02d--%2d:%02d" bh bm eh em))
	((and (= day eD) (= month eM) (= year eY))
	 (format "%2d:%02d" eh em))
	((and (= day bD) (= month bM) (= year bY))
	 (format "%2d:%02d" bh bm))
       	 "")))

(defun adam-parse-calendar-item (item)
  (setq result '(all-day ()))
  (dolist (key item result)
    (if (listp key)
	(cond
	 ((eq 'Subject (car key))
	  (setq result
		(plist-put result 'subject (cdr key))))
	 ((eq 'End (car key))
	  (setq result
		(plist-put result 'stop
			   (decode-time (date-to-time (cdr key))))))
	 ((eq 'IsAllDayEvent (car key))
	  (setq result
		(plist-put result 'all-day (cdr key))))
	 ((eq 'Start (car key))
	  (setq result
		(plist-put result 'start
			   (decode-time (date-to-time (cdr key))))))))))

(defun adam-get-meetings (date)
  (lexical-let
      ((promise (make-promise))
       (month (car date))
       (day (cadr date))
       (year (caddr date)))
    (exco-get-meetings-for-day
     "adam.washington@stfc.ac.uk"
     month day year
     (lambda (ident resp) (deliver promise resp)))
     (-filter
      (lambda (x)
	(pcase-let
	    ((`(,second ,minute ,hour ,date)
	      (plist-get x 'stop)))
	  (not
	   (and (eq date day) (eq hour 0) (eq minute 0)))))
      (mapcar #'adam-parse-calendar-item
	      (cdar (last (car (last (cdr (cadaar (retrieve promise)))))))))))

#+END_SRC

* org

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb))
  :general
  (:states '(normal) :keymaps 'org-mode-map :infix "c"
    "'" 'org-edit-special
    "vt" 'org-babel-tangle
    "d" 'org-deadline
    "s" 'org-schedule
    "e" 'org-export-dispatch)
  :config
  (setq org-agenda-files
	(quote
	 ("~/org/sync.org"
	  "~/org/appointments.org"
	  "~/org/personal-notes.org")))
  (setq calendar-latitude 53.3836)
  (setq calendar-longitude 1.4669)

  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-start-on-weekday nil)
  (setq org-return-follows-link t)
  (add-hook 'org-mode-hook
	    (lambda ()
	      (variable-pitch-mode t)
	      (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
	      (set-face-attribute 'org-block-begin-line nil :inherit 'fixed-pitch)
	      (set-face-attribute 'org-block-end-line nil :inherit 'fixed-pitch)
	      (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)))

  (defun adam-org-sunrise ()
    (concat
     (nth 1 (split-string (diary-sunrise-sunset)))
     " Sunrise for "
     (string-remove-prefix "(" (nth 9 (split-string (diary-sunrise-sunset))))))
  (defun adam-org-sunset ()
    (concat
     (nth 4 (split-string (diary-sunrise-sunset)))
     " Sunset"))

  (setq org-imenu-depth 4)
  (setq org-agenda-start-on-weekday nil)
  (customize-set-variable 'org-babel-load-languages (quote ((emacs-lisp . t) (python . t))))
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-fontify-natively t)
  (setq org-agenda-include-diary nil)
  (setq org-src-preserve-indentation t)
  (setq org-table-convert-region-max-lines 99999)
  (setq org-agenda-day-face-function (quote jd:org-agenda-day-face-holidays-function))
  (setq org-file-apps
	(quote
	 ((auto-mode . emacs)
	  ("\\.mm\\'" . default)
	  ("\\.x?html?\\'" . default)
	  ("\\.pdf\\'" . system))))

  (setq org-capture-templates
	(quote
	 (("m" "Unsorted Mail Tasks" entry
	   (file+headline "~/org/appointments.org" "Unsorted Mail")
	   "** TODO%?\n    SCHEDULED:%T\n\n    %a")
	  ("v" "Vocab" entry
	   (file+headline "~/org/appointments.org" "Vocab")
	   "** TODO %a\n    SCHEDULED:%T%?\n\n    %a"))))


  (setq org-latex-listings (quote minted))
  (setq org-latex-packages-alist (quote (("" "minted" nil))))
  (setq org-latex-pdf-process
	(quote
	 ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))

  (setq
   holiday-other-holidays
   (quote
    (
     (holiday-float 5 1 -1 "Spring Bank Holiday")
     (holiday-float 5 1 1 "May Day Bank Holiday")
     (holiday-float 8 1 -1 "Late Summer Bank Holiday")
     )))

  (defface org-agenda-date-beam
    `((t  :foreground ,(face-attribute 'font-lock-keyword-face :foreground)
	  :inherit org-agenda-date))
    "Face used for agenda entries on days when the ISIS beam is on"
    :group 'org-faces)

  (defface org-agenda-date-beam-weekend
    `((t  :foreground ,(face-attribute 'font-lock-keyword-face :foreground)
	  :inherit org-agenda-date-weekend))
    "Face used for agenda entries on days when the ISIS beam is on"
    :group 'org-faces)

  (defun my-org-agenda-day-face-holidays-function (date)
    "Compute DATE face for holidays."
    (unless (org-agenda-todayp date)
      (letrec
	  ((day-of-week (calendar-day-of-week date))
	   (weekend (or (= day-of-week 0)
			(= day-of-week 6)))
	   (files (org-agenda-files nil 'ifmode))
	   (entries (-flatten
		     (-map
		      (lambda (file) (org-agenda-get-day-entries file date))
		      files)))
	   (categories (-flatten (-map (lambda (entry)
					 (with-temp-buffer
					   (insert entry)
					   (org-get-category (point-min))))
				       entries))))
	(cond
	 ((and (-contains? categories "BeamOn")
	       (or weekend
		   (-contains? categories "Holidays")
		   (-contains? categories "Vacation")))
	  'org-agenda-date-beam-weekend)
	 ((-contains? categories "BeamOn")
	  'org-agenda-date-beam)
	 ((or weekend
	      (-contains? categories "Holidays")
	     (-contains? categories "Vacation"))
	  'org-agenda-date-weekend)
	 (t 'org-agenda-date)))))

  (setq
   org-agenda-day-face-function
   (function
    my-org-agenda-day-face-holidays-function))
					; (require 'org-notify)
  (setq org-agenda-custom-commands
	'(("c" . "My Custom Agendas")
	  ("cu" "Unscheduled TODO"
	   ((todo ""
		  ((org-agenda-overriding-header "\nUnscheduled TODO")
		   (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp)))))
	   nil
	   nil)))


  (require 'org-agenda)
  (bind-key "RET" 'org-agenda-goto org-agenda-mode-map)
  (bind-key [tab] 'org-agenda-switch-to org-agenda-mode-map)
  (add-hook 'org-mode-hook 'auto-fill-mode)
  (add-hook 'org-mode-hook 'flyspell-mode))
#+END_SRC

Display appointment reminders in X when available.  I stole this code
from somewhere and should give proper credit.

#+BEGIN_SRC emacs-lisp :tangle yes

(defun kdialog-popup (title msg)
  "Show a popup if we're on X, or echo it otherwise; TITLE is the title
of the message, MSG is the context.

Code stolen from: http://emacs-fu.blogspot.co.uk/2009/11/showing-pop-ups.html
"

  (interactive)
  (if
      (eq window-system 'x)
      (shell-command
       (concat "kdialog --title \"" title
               "\" --passivepopup \""  msg
               "\""))
    (message (concat title ": " msg))))

(defun kdialog-appt-display (min-to-appt new-time msg)
  (kdialog-popup (format "Appointment in %s minute(s)" min-to-appt) msg))
(setq appt-disp-window-function (function kdialog-appt-display))

#+END_SRC

We need the org-contrib package for some lesser known libraries

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-plus-contrib
  :ensure t)


#+END_SRC

** Calculate Local Contacting

The code below calculates uses the org-calendar to calculate the
expected local contacting payment.

#+BEGIN_SRC emacs-lisp :tangle yes

(defun get-timestamps (tags)
  (-map
   (lambda (x) (cdr (assoc "TIMESTAMP" x)))
   (-filter (lambda (x) (assoc "TIMESTAMP" x))
	    (org-map-entries
	     (lambda ()
	       (org-entry-properties))
	     tags
	     'agenda))))

(defun timestamp-to-dates (stamp)
  (-map
   #'calendar-gregorian-from-absolute
   (apply
    #'number-sequence
    (-map
     #'org-time-string-to-absolute
     (split-string
      stamp
      "--")))))

(defun local-contacting (dates)
  (apply
   '+
   (-map
    (lambda (x)
      (pcase x
	(`(,month ,day, year)
	 (pcase (org-day-of-week day month year)
	   (6 40.40)
	   (0 40.40)
	   (_ 20.20)
	   ))))
   dates)))

(defun calculate-local-contacting ()
  "Calculate expected local contacting fees."
  (interactive)
  (print
   (apply
    '+
    (-map
     (lambda (x)
       (local-contacting
	(timestamp-to-dates x)))
     (get-timestamps "+LocalContact+TODO=\"TODO\"")))))
#+END_SRC

** htmlize

 Org-mode uses the htmlize library to highlight the code in the
 exported documentation.  As long as I've installed the library, I
 should never need to think about it again.

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package htmlize
  :ensure t)

 #+END_SRC

** org-notmuch

We need to load the contrib package to get notmuch links into org

#+BEGIN_SRC emacs-lisp :tangle yes

(require 'org-notmuch)

#+END_SRC

** org-edna

This package allow much finer control over the triggers and blocking
in our org-mode files.  The manual can be found at
[[http://www.nongnu.org/org-edna-el/]]

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package org-edna
  :ensure t
  :config
  (org-edna-load))

#+END_SRC

* Prose


** LaTeX

Include useful mode hooks when moving into latex mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'auto-fill-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(setq TeX-PDF-mode t)
(setq TeX-view-program-list (quote (("Okular" "okular --unique %o#src:%n%b"))))
(setq TeX-view-program-selection
   (quote
    (((output-dvi style-pstricks)
      "dvips and gv")
     (output-dvi "Okular")
     (output-pdf "Evince")
     (output-html "xdg-open"))))
 #+END_SRC

 I like for each sentence in a LaTeX document to be its own line.
 That way, when I'm editing, only the relevant sections get marked in
 the version control, instead of the entire paragraph.  This code
 tries to alleviate the problem.  I'm not sure how well it work.

#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice LaTeX-fill-region-as-paragraph (around LaTeX-sentence-filling)
  "Start each sentence on a new line."
  (let ((from (ad-get-arg 0))
        (to-marker (set-marker (make-marker) (ad-get-arg 1)))
        tmp-end)
    (while (< from (marker-position to-marker))
      (forward-sentence)
      ;; might have gone beyond to-marker --- use whichever is smaller:
      (ad-set-arg 1 (setq tmp-end (min (point) (marker-position to-marker))))
      ad-do-it
      (ad-set-arg 0 (setq from (point)))
      (unless (or
               (bolp)
               (looking-at "\\s *$"))
        (LaTeX-newline)))
    (set-marker to-marker nil)))

(ad-activate 'LaTeX-fill-region-as-paragraph)


#+END_SRC
** Text Mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'text-mode-hook 'visual-line-mode)


 #+END_SRC

 There didn't used to be a built in word count function.  I believe
 that there is now, so I may not need this any longer.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun count-words (&optional begin end)
  "count words between BEGIN and END (region); if no region defined, count words in buffer"
  (interactive "r")
  (let ((b (if mark-active begin (point-min)))
      (e (if mark-active end (point-max))))
    (message "Word count: %s" (how-many "\\w+" b e))))



#+END_SRC
** langtool

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package langtool
  :ensure t
  :config
  (setq langtool-language-tool-jar "~/bin/LanguageTool-3.5/languagetool-commandline.jar"))
 #+END_SRC


** writegood-mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package writegood-mode
  :diminish writegood-mode
  :ensure t
  :config
  (add-hook 'text-mode-hook 'writegood-mode)
  (add-hook 'latex-mode-hook 'writegood-mode)
  (add-hook 'org-mode-hook 'writegood-mode))
 #+END_SRC

* Toys
** encourage-mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package encourage-mode
  :diminish encourage-mode
  :ensure t
  :init (encourage-mode))


 #+END_SRC

** selectric-mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package selectric-mode
  :ensure t)


 #+END_SRC


** Tidal 

#+BEGIN_SRC emacs-lisp :tangle yes
(if
    (file-exists-p "~/Code/tidal")
    (progn
      (add-to-list 'load-path "~/Code/tidal/" )
      (require 'tidal)))
#+END_SRC
** emojify

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package emojify
  :ensure t
  :init
  (setq emojify-display-style 'unicode) ; :-)
  (add-hook 'after-init-hook #'global-emojify-mode))


 #+END_SRC

* Utilities


** ace-window

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-window
  :ensure t
  :bind
  (("M-z" . ace-window))
  :config
  (setq aw-keys '(?f ?j ?d ?k ?s ?l ?a ?g ?h ?r ?u ?e ?i ?w ?o ?n ?c ?m ?v )))
 #+END_SRC

** alert

A basic emacs customication system.  Slack uses this to handle system
messages and other parts of emacs could probably benefit from it.  I
really need to tweak the customisation.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package alert
  :commands (alert)
  :init
  (setq alert-default-style 'libnotify))
#+END_SRC


** all-the-icons

Use the all-the-icons package to get icon fonts.

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package all-the-icons
  :ensure t)
 #+END_SRC

Automatically display file icons in dired.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package all-the-icons-dired
  :ensure t
  :config
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

#+END_SRC

Display icons when switching buffers

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package all-the-icons-ivy
  :ensure t
  :config
  (all-the-icons-ivy-setup))


#+END_SRC

** company

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'company-mode)
  (setq company-dabbrev-code-modes
   (quote
    (prog-mode batch-file-mode csharp-mode css-mode erlang-mode haskell-mode
    jde-mode lua-mode python-mode purescript-mode)))
  :diminish company-mode)
#+END_SRC

*** company-emoji

This should allow me to more easily type emoji.  Because that's what my life has been missing.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company-emoji
  :ensure t
  :config
  (add-to-list 'company-backends 'company-emoji))

#+END_SRC




*** company-math

Let's use company-math mode so that we don't have to keep using the TeX input method

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company-math
  :ensure t
  :config
  (add-to-list 'company-backends 'company-math-symbols-unicode))

#+END_SRC

😄


*** company-qml

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company-qml
  :ensure t
  :config
  (add-to-list 'company-backends 'company-qml))


#+END_SRC

** imenu-anywhere

This package allows me to do the imenu jump to any buffer with the
same major mode.  This should be a big boon when working on multi-file
projects (and not require greping my way around all of the time)

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package imenu-anywhere
  :general (:states '(normal) "i" 'ivy-imenu-anywhere)
  :ensure t)

#+END_SRC

** evil

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil
  :ensure t
  :config
  (setq evil-escape-unordered-key-sequence t)
  (setq evil-insert-state-modes
	'(comint-mode erc-mode eshell-mode geiser-repl-mode gud-mode inferior-apl-mode inferior-caml-mode inferior-emacs-lisp-mode inferior-j-mode inferior-python-mode inferior-scheme-mode inferior-sml-mode internal-ange-ftp-mode prolog-inferior-mode reb-mode shell-mode slime-repl-mode term-mode wdired-mode))
  (evil-mode)
  ;; (evil-add-hjkl-bindings
  ;;   eww-mode-map 'emacs
  ;;   (kbd "f") 'ace-link-eww
  ;;   (kbd "o") 'eww
  ;;   (kbd "r") 'eww-reload
  ;;   (kbd "gr") 'eww-readable)
  (add-hook 'git-commit-mode-hook #'evil-insert-state))
 #+END_SRC


*** evil collection

A set of evil bindings for multiple modes.  This should make life less
frustrating

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))

#+END_SRC

*** which-key



  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package which-key
  :diminish which-key-mode
  :ensure t
  :config
  (which-key-mode)
  (setq which-key-show-operator-state-maps t))
  #+END_SRC


*** evil-magit

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-magit
  :ensure t)
  #+END_SRC

*** evil org mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org
  :diminish evil-org-mode
  :ensure t
  :after org
  :config
  (require 'evil-org)
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook
            (lambda ()
              (evil-org-set-key-theme))))

#+END_SRC

*** evil-indent-plus
Evil indent plus does a great job at handling Python and Haskell
source code

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-indent-plus
  :ensure t
  :config
  (evil-indent-plus-default-bindings))

#+END_SRC


*** evil quickscope

evil quickscope highlight unique characters in the words around the
cursor to identify the best options for using the f/t/F/T keys for
navigation.  If there is no best single character, it uses a blue
highlight to indicate that a 2f/2F will still find the correct word.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-quickscope
  :ensure t
  :config
  (global-evil-quickscope-mode 1))

#+END_SRC

*** Evil Goggles

Evil google should make learning evil slightly easier, as it shows the
exact regions chosen.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-goggles
  :ensure t
  :config
  (evil-goggles-mode))

#+END_SRC

*** evil text object python

This package allows for using evil operations on the structure of
python statements, instead of just looking at things on a line by line
basis.  Due to Python's whitespace sensitive setup, this might be
necessary.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-text-object-python
  :ensure t
  :config
  (add-hook 'python-mode-hook 'evil-text-object-python-add-bindings))

#+END_SRC


*** evil matichit

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-matchit
  :ensure t
  :config
  (global-evil-matchit-mode 1))

#+END_SRC

*** general

The general package is a set of convenience scripts for defining key
bindings

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package general
  :ensure t
  :config
  (setq general-default-prefix "SPC")
  (setq general-default-non-normal-prefix "M-SPC")
  (setq general-default-states '(normal insert emacs))


  (general-define-key
   :states '(normal)
    "i" #'ivy-imenu-anywhere)

  (general-simulate-keys
   "C-c C-c" 't
   :docstring
   "Run whatever the native mode's C-c C-c command would be"
   :name
   general-simulate-C-c_C-c-in-emacs-state)

  (general-define-key
   "cc" #'general-simulate-C-c_C-c-in-emacs-state)

  (general-define-key
   :states '(normal)
   :keymaps 'org-mode-map
   "ce" 'org-export-dispatch
   "i" 'counsel-org-goto)

  (general-define-key
   :keymaps 'with-editor-mode-map
   "ck" 'with-editor-cancel)

  (general-define-key
   :keymaps '(org-mode-map)
   :infix "c"
   "'" 'org-edit-special
   "vt" 'org-babel-tangle)

  (general-define-key
   "/" 'swiper
   "?" 'swiper-all)

  (general-define-key
   :infix "x"
   "s" 'save-buffer
   "f" 'counsel-find-file
   "b" 'ivy-switch-buffer
   "rp" 'ivy-purpose-switch-buffer-with-some-purpose
   "rP" 'ivy-purpose-switch-buffer-with-purpose
   "B" 'ibuffer
   "k" 'kill-this-buffer
   "e" 'eval-last-sexp))

(defun avy-jump-link ()
   (interactive)
   (avy--generic-jump "https://" nil 'pre))

(general-define-key
 :prefix 'nil
 :infix 'nil
 "M-o" 'avy-jump-link)

#+END_SRC

#+RESULTS:


*** evil-escape

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-escape
  :ensure t
  :diminish evil-escape-mode
  :config
  (evil-escape-mode)
  (setq-default evil-escape-key-sequence "jk"))
  #+END_SRC


*** evil easymotion

easymotion helps with the fact that I don't instantly know how many
lines or characters I'm looking at 90% of the time when using evil.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil-easymotion
  :ensure t
  :config
  (evilem-default-keybindings "RET"))


#+END_SRC

*** evil commentary

Evil commentary should hopefully give me the commenting options that
evil-nerd-commenter sould never get working right

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-commentary
  :ensure t
  :config
  (evil-commentary-mode))
#+END_SRC

*** evil numbers

    This should allow for easier number manipulation in evil mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-numbers
  :ensure t
  :config
  (general-define-key
   :prefix 'nil
   :states '(normal)
   :infix "g"
   "+" 'evil-numbers/inc-at-pt
   "-" 'evil-numbers/dec-at-pt))

#+END_SRC

** eyebrowse

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package eyebrowse
  :ensure t
  :config
  (eyebrowse-mode)
  (general-define-key
   :states '(normal insert emacs)
   :infix "w"
   "j" 'eyebrowse-next-window-config
   "k" 'eyebrowse-prev-window-config
   "r" 'eyebrowse-rename-window-config
   "/" 'eyebrowse-switch-to-window-config
   "x" 'eyebrowse-close-window-config
   "0" 'eyebrowse-switch-to-window-config-0
   "1" 'eyebrowse-switch-to-window-config-1
   "2" 'eyebrowse-switch-to-window-config-2
   "3" 'eyebrowse-switch-to-window-config-3
   "4" 'eyebrowse-switch-to-window-config-4
   "5" 'eyebrowse-switch-to-window-config-5
   "6" 'eyebrowse-switch-to-window-config-6
   "7" 'eyebrowse-switch-to-window-config-7
   "8" 'eyebrowse-switch-to-window-config-8
   "9" 'eyebrowse-switch-to-window-config-9))

#+END_SRC
** flycheck

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :diminish flycheck-mode
  :config
  (flycheck-define-checker
   proselint
   "A linter for plain prose"
   :command ("proselint" source)
   :standard-input f
   :error-patterns
   ((warning line-start (file-name) ":" line ":" column ": " (message) line-end))
   :modes (markdown-mode text-mode org-mode))
  (add-to-list 'flycheck-checkers 'proselint)
  (add-hook 'prog-mode-hook 'flycheck-mode)
  (flycheck-add-next-checker 'python-flake8 'python-pylint))
 #+END_SRC
** hydra

   Hydra is a useful little utility for making custom keyboard DSLs.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package hydra
  :ensure t
  :config

  (defhydra hydra-flycheck ()
    ("X" (progn
	   (let ((current-prefix-arg 4))
	   (call-interactively 'flycheck-disable-checker))) "enable" :color blue)
    ("x" flycheck-disable-checker "disable")
    ("v" flycheck-verify-setup "verify")
    ("c" flycheck-select-checker "checkerer")
    ("e" flycheck-display-error-at-point "explain" :color blue)
    ("j" flycheck-next-error "next")
    ("k" flycheck-previous-error "previous"))
  (general-define-key
   :keymaps '(flycheck-mode-map)
   "f" 'hydra-flycheck/body)

  (defhydra hydra-flyspell ()
    ("j" flyspell-goto-next-error "next")
    ("l" flyspell-correct-previous-word-generic "fix")
    ("I" ispell-pdict-save "insert")
    ("a" flyspell-auto-correct-word "auto"))
  (general-define-key
   :keymaps '(flyspell-mode-map)
   "f" 'hydra-flyspell/body)

  (defhydra hydra-apropos (:color blue)
    "Apropos"
    ("a" apropos "apropos")
    ("c" apropos-command "cmd")
    ("d" apropos-documentation "doc")
    ("e" apropos-value "val")
    ("l" apropos-library "lib")
    ("o" apropos-user-option "option")
    ("u" apropos-user-option "option")
    ("v" apropos-variable "var")
    ("i" info-apropos "info")
    ("t" tags-apropos "tags")
    ("z" hydra-customize-apropos/body "customize"))
  (defhydra hydra-customize-apropos (:color blue)
    "Apropos (customize)"
    ("a" customize-apropos "apropos")
    ("f" customize-apropos-faces "faces")
    ("g" customize-apropos-groups "groups")
    ("o" customize-apropos-options "options"))
  (general-define-key
   " f" 'hydra-apropos/body)

  (defhydra hydra-windows (:hint nil)
   "
Movement^^	^Resize^	^Split^         ^Dedicate^
----------------------------------------------------------------
_h_ ←		_H_ X←	_|_ vertical	_d_ purpose
_j_ ↓		_J_ X↓^	_-_ horizontal	_D_ buffer
_k_ ↑		_K_ X↑^	_x_ close
_l_ →		_L_ X→
_q_uit		_=_ equalise
"
   ("j" windmove-down)
   ("k" windmove-up)
   ("h" windmove-left)
   ("l" windmove-right)
   ("J" shrink-window)
   ("K" enlarge-window)
   ("H" shrink-window-horizontally)
   ("L" enlarge-window-horizontally)
   ("=" balance-windows)
   ("-" split-window-below)
   ("|" split-window-right)
   ("x" delete-window)
   ("d" purpose-toggle-window-purpose-dedicated)
   ("D" purpose-toggle-window-buffer-dedicated)
   ("q" nil))
  (general-define-key
   " W" 'hydra-windows/body))
#+END_SRC
*** hydra-ivy

    Add hydra bindings to ivy

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package ivy-hydra
  :ensure t)

#+END_SRC

** Key Bindings

This is a place for my own personal key bindings.

#+BEGIN_SRC emacs-lisp :tangle yes

(bind-key "M-/" 'hippie-expand)
(bind-key "M-d" 'avy-goto-char-timer)

(defun my-notmuch-archive (&optional arg)
  (interactive "p")
  (kmacro-exec-ring-item (quote ([45 117 110 114 101 97 100 32 45 105 110 98 111 120 return] 0 "%d")) arg))

(bind-key "a" 'my-notmuch-archive 'notmuch-search-mode-map)

#+END_SRC
*** Kill this buffer

I hate when emacs asks me which buffer to kill, because it's my
current buffer 99% of the time.  Just change the key binding and be
done with it.

#+BEGIN_SRC emacs-lisp :tangle yes
(bind-key "C-x k" 'kill-this-buffer)

#+END_SRC

*** Refresh Key

Refreshing buffers is a constant chore that really should have it's
own hotkey.  Why not steal F5 from the browser?

#+BEGIN_SRC emacs-lisp :tangle yes

 (global-set-key
  (kbd "<f5>")
  (lambda (&optional force-reverting)
    "Interactive call to revert-buffer. Ignoring the auto-save
 file and not requesting for confirmation. When the current buffer
 is modified, the command refuses to revert it, unless you specify
 the optional argument: force-reverting to true."
    (interactive "P")
    ;;(message "force-reverting value is %s" force-reverting)
    (if (or force-reverting (not (buffer-modified-p)))
        (revert-buffer :ignore-auto :noconfirm)
      (error "The buffer has been modified"))))

#+END_SRC
** keyfreq

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package keyfreq
  :ensure t
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
 #+END_SRC


** ivy

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ivy
  :general (:infix "x" "b" 'ivy-switch-buffer)
  :ensure t
  :diminish ivy-mode)
 #+END_SRC


*** counsel

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel
  :bind   (("C-s" . swiper)
           ("C-c C-r" . ivy-resume)
           ("<f6>" . ivy-resume)
           ("C-x b" . ivy-switch-buffer)
           ("M-x" . counsel-M-x)
           ("M-y" . counsel-yank-pop)
           ("C-x C-f" . counsel-find-file)
           ("<f1> f" . counsel-describe-function)
           ("<f1> v" . counsel-describe-variable)
           ("<f1> l" . counsel-load-library)
           ("<f2> i" . counsel-info-lookup-symbol)
           ("C-x 8 RET" . counsel-unicode-char)
           ("<f2> u" . counsel-unicode-char))
  :general
  (:states '(normal) :keymaps 'org-mode-map "i" 'counsel-org-goto)
  (:infix "x" "f" 'counsel-find-file)
  :diminish counsel-mode
  :ensure t
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq counsel-find-file-at-point t)
  (setq counsel-mode t))
  #+END_SRC

**** counsel-dash

Dash is an offline documentation framework.  The open source version
is [[https://zealdocs.org/][Zeal]].  It's useful for getting programming documentation without
needing to load up a google search.  It's especially useful when
there's no internet access or the scipy website is down yet again.

FIXME: The current version of counsel-dash relies on helm-dash, which
subsequently relies on Helm.  I may be able to get rid of the helm
dependency in the future if this changes.  I need to check on this
from time to time and see if anything has improved.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel-dash 
  :ensure t
  :config
  (setq counsel-dash-browser-func 'eww)
  (setq counsel-dash-docsets-path "~/.local/share/Zeal/Zeal/docsets")
  (add-hook 'python-mode-hook
	    (lambda () (setq-local counsel-dash-docsets
			      '("SciPy" "NumPy" "Matplotlib" "Python_2" "Python_3" "Qt_5"))))
  (add-hook 'elisp-mode
	    (lambda () (setq-local counsel-dash-docsets
			      '("Emacs_Lisp"))))
  (add-hook 'haskell-mode
	    (lambda () (setq-local counsel-dash-docsets '("Haskell"))))
  (add-hook 'html-mode
	    (lambda () (setq-local counsel-dash-docsets '("HTML" "CSS"))))
  (evil-define-key 'normal prog-mode-map
    "zd" 'counsel-dash))

#+END_SRC

*** flyspell-correct-ivy

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flyspell-correct-ivy
  :ensure t
  :config
  (require 'flyspell-correct-ivy))
  #+END_SRC


** link-hint

 #+BEGIN_SRC emacs-lisp :tangle no
(use-package link-hint
  :ensure t
  :bind
  ("C-c o" . link-hint-open-link)
  ("C-c c" . link-hint-copy-link))
 #+END_SRC
 
** ace-link

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-link
  :ensure t
  :config
  (ace-link-setup-default)
  (general-define-key
   :prefix nil
   :infix nil
   :keymaps 'org-mode-map
   "M-o" 'ace-link-org))
#+END_SRC


** projectile

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :ensure t
  :init
  (setq projectile-keymap-prefix (kbd "C-c C-p"))
  (setq projectile-mode-line
	'(:eval
	  (if
	      (file-remote-p default-directory)
	      ""
	    (format " {%s}" (projectile-project-name)))))
  :config
  (setq projectile-completion-system 'ivy)
  (general-define-key
   :infix "p"
   :states '(normal emacs insert)
   "xe" 'projectile-run-eshell
   "xs" 'projectile-run-shell
   "xt" 'projectile-run-term
   "f" 'counsel-projectile
   "b" 'counsel-projectile-switch-to-buffer
   "d" 'projectile-find-dir
   "D" 'projectile-dired
   "p" 'counsel-projectile-switch-project
   "P" 'projectile-test-project
   "g" 'counsel-projectile-rg
   "s" 'projectile-save-project-buffers
   "B" 'projectile-ibuffer
   "k" 'projectile-kill-buffers
   "c" 'projectile-compile-project
   "v" 'projectile-vc
   "t" 'projectile-find-tag
   "T" 'projectile-regenerate-tags
   "R" 'projectile-replace-regexp
   "r" 'projectile-run-project)
  (projectile-global-mode))
 #+END_SRC


*** counsel-projectile

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel-projectile
  :ensure t)
 #+END_SRC



** recentf

   Recentf keeps track of recently edited files.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'recentf)
(recentf-mode)

#+END_SRC
** space-line 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package spaceline
  :ensure t
  :config
  (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state))

(use-package spaceline-all-the-icons
  :ensure t
  :after spaceline
  :config
  (spaceline-all-the-icons-theme)
  (spaceline-toggle-all-the-icons-buffer-size-off)
  (spaceline-toggle-all-the-icons-time-off)
  (spaceline-toggle-all-the-icons-region-info-off)
  (spaceline-toggle-all-the-icons-git-ahead-on)
  (spaceline-toggle-all-the-icons-projectile-on))
#+END_SRC


** yasnippets

Yasnippets provide programmable skeletons for filling out boilerplate

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet
  :ensure t
  :config
  (setq yas-indent-line 'fixed)
  (yas-global-mode)
  (general-define-key
   :states '(normal)
   :keymaps 'yas-minor-mode-map
   "yv" 'yas-visit-snippet-file
   "yn" 'yas-new-snippet
   "ys" 'yas-insert-snippet))
#+END_SRC

*** yasnippets-mpa

#+BEGIN_SRC emacs-lisp :tangle yes
(defun mpa-parse-param (param)
  (pcase-let
      ((`(,name . ,value) (split-string param "=")))
    (cond
    ((string-equal name "OutputWorkspace")
    "self.declareProperty(\n            WorkspaceProperty(name=\"OutputWorkspace\",\n                defaultValue=\"\",\n                direction=Direction.Output))")
     ((eq value '())
      (format "self.declareProperty(\"%s\", defaultValue=0)" name))
     ((string-match "[0-9]+" (car value))
      (format "self.declareProperty(\"%s\", defaultValue=%s)"
	      name
	      (string-to-number (car value))))
     ((string-equal (car value) "file")
      (format "self.declareProperty(\n            FileProperty(name=\"%s\",\n                defaultValue=\"\",\n                action=FileAction.%s))" name (cadr value)))
     ((string-equal (car value) "wksp")
      (format "self.declareProperty(\n            WorkspaceProperty(name=\"%s\",\n                defaultValue=\"\",\n                direction=Direction.%s))" name (cadr value)))
     (t (format "self.declareProperty(\"%s\", defaultValue=\"%s\")" name (car value))))))

(defun mpa-get-param (param)
  (pcase-let
      ((`(,name . ,value) (split-string param "=")))
    (cond
     ((string-equal name "OutputWorkspace") "")
     ('t (format "%s = self.getProperty(\"%s\").value" name name)))))


(defun mpf-parse-param (param)
  (pcase-let
      ((`(,name . ,value) (split-string param "=")))
    (cond
     ((eq value '())
      (format "self.declareProperty(\"%s\", defaultValue=0.0)" name))
     ((string-match "[0-9]+" (car value))
      (format "self.declareProperty(\"%s\", defaultValue=%s)"
	      name
	      (string-to-number (car value))))
     (t (format "self.declareProperty(\"%s\", defaultValue=%s)" name (car value))))))

(defun mpf-get-param (param)
  (pcase-let
      ((`(,name . ,value) (split-string param "=")))
    (format "%s = self.getParameter(\"%s\")" name name)))
#+END_SRC

** whitespace-cleanup-mode

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package whitespace-cleanup-mode
  :ensure t
  :diminish whitespace-cleanup-mode
  :init
  (global-whitespace-cleanup-mode))
 #+END_SRC


** window-purpose

 #+BEGIN_SRC emacs-lisp :tangle yes
(use-package window-purpose
  :ensure t
  :after '(ivy)
  :general
  (:infix "xr"
  "p" 'ivy-purpose-switch-buffer-with-some-purpose
  "P" 'ivy-purpose-switch-buffer-with-some-purpose)
  :bind
  ("C-c C-, C-d" . purpose-toggle-window-purpose-dedicated)
  ("C-c C-, C-D" . purpose-toggle-window-buffer-dedicated)
  ("C-c C-, C-1" . purpose-delete-non-dedicated-windows)
  ("C-c C-, C-b" . purpose-switch-buffer-with-purpose)
  ("C-c C-, C-s" . purpose-save-window-layout)
  ("C-c C-, C-l" . purpose-load-window-layout)
  :config
  (purpose-mode)
  (purpose-x-kill-setup)
  (purpose-x-magit-single-on)
  (add-to-list 'purpose-user-mode-purposes '(haskell-cabal-mode . edit))
  (add-to-list 'purpose-user-mode-purposes '(eshell-mode . terminal))
  (add-to-list 'purpose-user-mode-purposes '(jabber-chat-mode . chat))
  (add-to-list 'purpose-user-mode-purposes '(slack-mode . chat))
  (add-to-list 'purpose-user-mode-purposes '(notmuch-hello-mode . chat))
  (add-to-list 'purpose-user-mode-purposes '(notmuch-message-mode . chat))
  (add-to-list 'purpose-user-mode-purposes '(notmuch-search-mode . chat))
  (add-to-list 'purpose-user-mode-purposes '(notmuch-show-mode . chat))
  (add-to-list 'purpose-user-mode-purposes '(org-mode . edit))
  (add-to-list 'purpose-user-mode-purposes '(ein:notebook-multilang-mode . edit))
  (add-to-list 'purpose-user-mode-purposes '(systemd-mode . edit))
  (add-to-list 'purpose-user-mode-purposes '(help-mode . help))
  (add-to-list 'purpose-user-mode-purposes '(Info-mode . help))
  (add-to-list 'purpose-user-mode-purposes '(Custom-mode . custom))
  (purpose-compile-user-configuration))
 #+END_SRC


** Winner

   Winner mode allows me to undo and redo changes to the window layout
   within emacs.  Very useful when I make a mistake.  It's also handy
   for focusing on a single window, then returning to my previous,
   more complex layout with a single C-c ←

#+BEGIN_SRC emacs-lisp :tangle yes
(winner-mode)
#+END_SRC
